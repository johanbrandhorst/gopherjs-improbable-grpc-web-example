// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/library/book_service.proto

/*
Package library is a generated protocol buffer package.

Package library exposes a list of books
over a gRPC API.

It is generated from these files:
	proto/library/book_service.proto

It has these top-level messages:
	Publisher
	Book
	GetBookRequest
	QueryBooksRequest
	Collection
	BookMessage
	BookResponse
*/
package library

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"
import _ "github.com/johanbrandhorst/protobuf/proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// BookType describes the different types
// a book in the library can be.
type BookType int32

const (
	// Hardcover is a book with a hard back.
	BookType_HARDCOVER BookType = 0
	// Paperback is a book with a soft back.
	BookType_PAPERBACK BookType = 1
	// Audiobook is an audio recording of the book.
	BookType_AUDIOBOOK BookType = 2
)

var BookType_name = map[int32]string{
	0: "HARDCOVER",
	1: "PAPERBACK",
	2: "AUDIOBOOK",
}
var BookType_value = map[string]int32{
	"HARDCOVER": 0,
	"PAPERBACK": 1,
	"AUDIOBOOK": 2,
}

func (x BookType) String() string {
	return proto.EnumName(BookType_name, int32(x))
}
func (BookType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Publisher describes a Book Publisher.
type Publisher struct {
	// Name is the name of the Publisher.
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *Publisher) Reset()                    { *m = Publisher{} }
func (m *Publisher) String() string            { return proto.CompactTextString(m) }
func (*Publisher) ProtoMessage()               {}
func (*Publisher) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Publisher) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Book represents a book in the library.
type Book struct {
	// Isbn is the ISBN number of the book.
	Isbn int64 `protobuf:"varint,1,opt,name=isbn" json:"isbn,omitempty"`
	// Title is the title of the book.
	Title string `protobuf:"bytes,2,opt,name=title" json:"title,omitempty"`
	// Author is the author of the book.
	Author string `protobuf:"bytes,3,opt,name=author" json:"author,omitempty"`
	// BookType is the type of the book.
	BookType BookType `protobuf:"varint,4,opt,name=book_type,json=bookType,enum=library.BookType" json:"book_type,omitempty"`
	// PublishingMethod is the publishing method
	// used for this Book.
	//
	// Types that are valid to be assigned to PublishingMethod:
	//	*Book_SelfPublished
	//	*Book_Publisher
	PublishingMethod isBook_PublishingMethod `protobuf_oneof:"publishing_method"`
	// PublicationDate is the time of publication of the book.
	PublicationDate *google_protobuf.Timestamp `protobuf:"bytes,7,opt,name=publication_date,json=publicationDate" json:"publication_date,omitempty"`
}

func (m *Book) Reset()                    { *m = Book{} }
func (m *Book) String() string            { return proto.CompactTextString(m) }
func (*Book) ProtoMessage()               {}
func (*Book) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isBook_PublishingMethod interface{ isBook_PublishingMethod() }

type Book_SelfPublished struct {
	SelfPublished bool `protobuf:"varint,5,opt,name=self_published,json=selfPublished,oneof"`
}
type Book_Publisher struct {
	Publisher *Publisher `protobuf:"bytes,6,opt,name=publisher,oneof"`
}

func (*Book_SelfPublished) isBook_PublishingMethod() {}
func (*Book_Publisher) isBook_PublishingMethod()     {}

func (m *Book) GetPublishingMethod() isBook_PublishingMethod {
	if m != nil {
		return m.PublishingMethod
	}
	return nil
}

func (m *Book) GetIsbn() int64 {
	if m != nil {
		return m.Isbn
	}
	return 0
}

func (m *Book) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Book) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *Book) GetBookType() BookType {
	if m != nil {
		return m.BookType
	}
	return BookType_HARDCOVER
}

func (m *Book) GetSelfPublished() bool {
	if x, ok := m.GetPublishingMethod().(*Book_SelfPublished); ok {
		return x.SelfPublished
	}
	return false
}

func (m *Book) GetPublisher() *Publisher {
	if x, ok := m.GetPublishingMethod().(*Book_Publisher); ok {
		return x.Publisher
	}
	return nil
}

func (m *Book) GetPublicationDate() *google_protobuf.Timestamp {
	if m != nil {
		return m.PublicationDate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Book) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Book_OneofMarshaler, _Book_OneofUnmarshaler, _Book_OneofSizer, []interface{}{
		(*Book_SelfPublished)(nil),
		(*Book_Publisher)(nil),
	}
}

func _Book_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Book)
	// publishing_method
	switch x := m.PublishingMethod.(type) {
	case *Book_SelfPublished:
		t := uint64(0)
		if x.SelfPublished {
			t = 1
		}
		b.EncodeVarint(5<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *Book_Publisher:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Publisher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Book.PublishingMethod has unexpected type %T", x)
	}
	return nil
}

func _Book_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Book)
	switch tag {
	case 5: // publishing_method.self_published
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.PublishingMethod = &Book_SelfPublished{x != 0}
		return true, err
	case 6: // publishing_method.publisher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Publisher)
		err := b.DecodeMessage(msg)
		m.PublishingMethod = &Book_Publisher{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Book_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Book)
	// publishing_method
	switch x := m.PublishingMethod.(type) {
	case *Book_SelfPublished:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case *Book_Publisher:
		s := proto.Size(x.Publisher)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// GetBookRequest is the input to the GetBook method.
type GetBookRequest struct {
	// Isbn is the ISBN with which
	// to match against the ISBN of a book in the library.
	Isbn int64 `protobuf:"varint,1,opt,name=isbn" json:"isbn,omitempty"`
}

func (m *GetBookRequest) Reset()                    { *m = GetBookRequest{} }
func (m *GetBookRequest) String() string            { return proto.CompactTextString(m) }
func (*GetBookRequest) ProtoMessage()               {}
func (*GetBookRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GetBookRequest) GetIsbn() int64 {
	if m != nil {
		return m.Isbn
	}
	return 0
}

// QueryBooksRequest is the input to the QueryBooks method.
type QueryBooksRequest struct {
	// AuthorPrefix is the prefix with which
	// to match against the author of a book in the library.
	AuthorPrefix string `protobuf:"bytes,1,opt,name=author_prefix,json=authorPrefix" json:"author_prefix,omitempty"`
}

func (m *QueryBooksRequest) Reset()                    { *m = QueryBooksRequest{} }
func (m *QueryBooksRequest) String() string            { return proto.CompactTextString(m) }
func (*QueryBooksRequest) ProtoMessage()               {}
func (*QueryBooksRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *QueryBooksRequest) GetAuthorPrefix() string {
	if m != nil {
		return m.AuthorPrefix
	}
	return ""
}

// Collection is a collection of books
type Collection struct {
	// Books is a list of books
	Books []*Book `protobuf:"bytes,1,rep,name=books" json:"books,omitempty"`
}

func (m *Collection) Reset()                    { *m = Collection{} }
func (m *Collection) String() string            { return proto.CompactTextString(m) }
func (*Collection) ProtoMessage()               {}
func (*Collection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Collection) GetBooks() []*Book {
	if m != nil {
		return m.Books
	}
	return nil
}

// BookMessage is used to discuss books
type BookMessage struct {
	// Types that are valid to be assigned to Content:
	//	*BookMessage_Name
	//	*BookMessage_Message
	Content isBookMessage_Content `protobuf_oneof:"content"`
}

func (m *BookMessage) Reset()                    { *m = BookMessage{} }
func (m *BookMessage) String() string            { return proto.CompactTextString(m) }
func (*BookMessage) ProtoMessage()               {}
func (*BookMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type isBookMessage_Content interface{ isBookMessage_Content() }

type BookMessage_Name struct {
	Name string `protobuf:"bytes,1,opt,name=name,oneof"`
}
type BookMessage_Message struct {
	Message string `protobuf:"bytes,2,opt,name=message,oneof"`
}

func (*BookMessage_Name) isBookMessage_Content()    {}
func (*BookMessage_Message) isBookMessage_Content() {}

func (m *BookMessage) GetContent() isBookMessage_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *BookMessage) GetName() string {
	if x, ok := m.GetContent().(*BookMessage_Name); ok {
		return x.Name
	}
	return ""
}

func (m *BookMessage) GetMessage() string {
	if x, ok := m.GetContent().(*BookMessage_Message); ok {
		return x.Message
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*BookMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _BookMessage_OneofMarshaler, _BookMessage_OneofUnmarshaler, _BookMessage_OneofSizer, []interface{}{
		(*BookMessage_Name)(nil),
		(*BookMessage_Message)(nil),
	}
}

func _BookMessage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*BookMessage)
	// content
	switch x := m.Content.(type) {
	case *BookMessage_Name:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Name)
	case *BookMessage_Message:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.Message)
	case nil:
	default:
		return fmt.Errorf("BookMessage.Content has unexpected type %T", x)
	}
	return nil
}

func _BookMessage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*BookMessage)
	switch tag {
	case 1: // content.name
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Content = &BookMessage_Name{x}
		return true, err
	case 2: // content.message
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Content = &BookMessage_Message{x}
		return true, err
	default:
		return false, nil
	}
}

func _BookMessage_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*BookMessage)
	// content
	switch x := m.Content.(type) {
	case *BookMessage_Name:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Name)))
		n += len(x.Name)
	case *BookMessage_Message:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Message)))
		n += len(x.Message)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// BookResponse is used to discuss books
type BookResponse struct {
	// Message is a message from a user.
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *BookResponse) Reset()                    { *m = BookResponse{} }
func (m *BookResponse) String() string            { return proto.CompactTextString(m) }
func (*BookResponse) ProtoMessage()               {}
func (*BookResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *BookResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*Publisher)(nil), "library.Publisher")
	proto.RegisterType((*Book)(nil), "library.Book")
	proto.RegisterType((*GetBookRequest)(nil), "library.GetBookRequest")
	proto.RegisterType((*QueryBooksRequest)(nil), "library.QueryBooksRequest")
	proto.RegisterType((*Collection)(nil), "library.Collection")
	proto.RegisterType((*BookMessage)(nil), "library.BookMessage")
	proto.RegisterType((*BookResponse)(nil), "library.BookResponse")
	proto.RegisterEnum("library.BookType", BookType_name, BookType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for BookService service

type BookServiceClient interface {
	// GetBook returns a Book from the library
	// that matches the ISBN provided, if found.
	// Otherwise it returns a NotFound error.
	GetBook(ctx context.Context, in *GetBookRequest, opts ...grpc.CallOption) (*Book, error)
	// QueryBooks returns all Books whos author
	// matches the author prefix provided, as a stream
	// of Books.
	QueryBooks(ctx context.Context, in *QueryBooksRequest, opts ...grpc.CallOption) (BookService_QueryBooksClient, error)
	// MakeCollection takes a stream of books and returns a Book collection.
	MakeCollection(ctx context.Context, opts ...grpc.CallOption) (BookService_MakeCollectionClient, error)
	// BookChat allows discussion about books
	BookChat(ctx context.Context, opts ...grpc.CallOption) (BookService_BookChatClient, error)
}

type bookServiceClient struct {
	cc *grpc.ClientConn
}

func NewBookServiceClient(cc *grpc.ClientConn) BookServiceClient {
	return &bookServiceClient{cc}
}

func (c *bookServiceClient) GetBook(ctx context.Context, in *GetBookRequest, opts ...grpc.CallOption) (*Book, error) {
	out := new(Book)
	err := grpc.Invoke(ctx, "/library.BookService/GetBook", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookServiceClient) QueryBooks(ctx context.Context, in *QueryBooksRequest, opts ...grpc.CallOption) (BookService_QueryBooksClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BookService_serviceDesc.Streams[0], c.cc, "/library.BookService/QueryBooks", opts...)
	if err != nil {
		return nil, err
	}
	x := &bookServiceQueryBooksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BookService_QueryBooksClient interface {
	Recv() (*Book, error)
	grpc.ClientStream
}

type bookServiceQueryBooksClient struct {
	grpc.ClientStream
}

func (x *bookServiceQueryBooksClient) Recv() (*Book, error) {
	m := new(Book)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bookServiceClient) MakeCollection(ctx context.Context, opts ...grpc.CallOption) (BookService_MakeCollectionClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BookService_serviceDesc.Streams[1], c.cc, "/library.BookService/MakeCollection", opts...)
	if err != nil {
		return nil, err
	}
	x := &bookServiceMakeCollectionClient{stream}
	return x, nil
}

type BookService_MakeCollectionClient interface {
	Send(*Book) error
	CloseAndRecv() (*Collection, error)
	grpc.ClientStream
}

type bookServiceMakeCollectionClient struct {
	grpc.ClientStream
}

func (x *bookServiceMakeCollectionClient) Send(m *Book) error {
	return x.ClientStream.SendMsg(m)
}

func (x *bookServiceMakeCollectionClient) CloseAndRecv() (*Collection, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Collection)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bookServiceClient) BookChat(ctx context.Context, opts ...grpc.CallOption) (BookService_BookChatClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BookService_serviceDesc.Streams[2], c.cc, "/library.BookService/BookChat", opts...)
	if err != nil {
		return nil, err
	}
	x := &bookServiceBookChatClient{stream}
	return x, nil
}

type BookService_BookChatClient interface {
	Send(*BookMessage) error
	Recv() (*BookResponse, error)
	grpc.ClientStream
}

type bookServiceBookChatClient struct {
	grpc.ClientStream
}

func (x *bookServiceBookChatClient) Send(m *BookMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *bookServiceBookChatClient) Recv() (*BookResponse, error) {
	m := new(BookResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for BookService service

type BookServiceServer interface {
	// GetBook returns a Book from the library
	// that matches the ISBN provided, if found.
	// Otherwise it returns a NotFound error.
	GetBook(context.Context, *GetBookRequest) (*Book, error)
	// QueryBooks returns all Books whos author
	// matches the author prefix provided, as a stream
	// of Books.
	QueryBooks(*QueryBooksRequest, BookService_QueryBooksServer) error
	// MakeCollection takes a stream of books and returns a Book collection.
	MakeCollection(BookService_MakeCollectionServer) error
	// BookChat allows discussion about books
	BookChat(BookService_BookChatServer) error
}

func RegisterBookServiceServer(s *grpc.Server, srv BookServiceServer) {
	s.RegisterService(&_BookService_serviceDesc, srv)
}

func _BookService_GetBook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookServiceServer).GetBook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/library.BookService/GetBook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookServiceServer).GetBook(ctx, req.(*GetBookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookService_QueryBooks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryBooksRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BookServiceServer).QueryBooks(m, &bookServiceQueryBooksServer{stream})
}

type BookService_QueryBooksServer interface {
	Send(*Book) error
	grpc.ServerStream
}

type bookServiceQueryBooksServer struct {
	grpc.ServerStream
}

func (x *bookServiceQueryBooksServer) Send(m *Book) error {
	return x.ServerStream.SendMsg(m)
}

func _BookService_MakeCollection_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BookServiceServer).MakeCollection(&bookServiceMakeCollectionServer{stream})
}

type BookService_MakeCollectionServer interface {
	SendAndClose(*Collection) error
	Recv() (*Book, error)
	grpc.ServerStream
}

type bookServiceMakeCollectionServer struct {
	grpc.ServerStream
}

func (x *bookServiceMakeCollectionServer) SendAndClose(m *Collection) error {
	return x.ServerStream.SendMsg(m)
}

func (x *bookServiceMakeCollectionServer) Recv() (*Book, error) {
	m := new(Book)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _BookService_BookChat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BookServiceServer).BookChat(&bookServiceBookChatServer{stream})
}

type BookService_BookChatServer interface {
	Send(*BookResponse) error
	Recv() (*BookMessage, error)
	grpc.ServerStream
}

type bookServiceBookChatServer struct {
	grpc.ServerStream
}

func (x *bookServiceBookChatServer) Send(m *BookResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *bookServiceBookChatServer) Recv() (*BookMessage, error) {
	m := new(BookMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _BookService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "library.BookService",
	HandlerType: (*BookServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBook",
			Handler:    _BookService_GetBook_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "QueryBooks",
			Handler:       _BookService_QueryBooks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MakeCollection",
			Handler:       _BookService_MakeCollection_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "BookChat",
			Handler:       _BookService_BookChat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/library/book_service.proto",
}

func init() { proto.RegisterFile("proto/library/book_service.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 630 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0xb5, 0xfb, 0x95, 0x66, 0xda, 0x84, 0x74, 0x5b, 0xc0, 0xf2, 0xa5, 0x91, 0x8b, 0x84, 0x85,
	0x84, 0x53, 0xd2, 0x03, 0x95, 0x10, 0x82, 0x24, 0xad, 0x08, 0x54, 0x55, 0x82, 0x29, 0x1c, 0xb8,
	0x44, 0xb6, 0x33, 0xb5, 0xdd, 0xda, 0x5e, 0xb3, 0xbb, 0x81, 0xe6, 0xcc, 0x2f, 0xe2, 0xdf, 0x21,
	0x4e, 0xc8, 0x5e, 0x3b, 0xa9, 0x29, 0x42, 0xe2, 0xb6, 0x6f, 0xe6, 0xbd, 0xf5, 0xbc, 0x37, 0x5a,
	0x43, 0x3b, 0x65, 0x54, 0xd0, 0x4e, 0x14, 0xba, 0xcc, 0x61, 0xf3, 0x8e, 0x4b, 0xe9, 0xf5, 0x84,
	0x23, 0xfb, 0x1a, 0x7a, 0x68, 0xe5, 0x2d, 0x52, 0x2b, 0x7a, 0xfa, 0xbe, 0x4f, 0xa9, 0x1f, 0x61,
	0x27, 0x2f, 0xbb, 0xb3, 0xcb, 0x8e, 0x08, 0x63, 0xe4, 0xc2, 0x89, 0x53, 0xc9, 0xd4, 0x8f, 0xfd,
	0x50, 0x04, 0x33, 0xd7, 0xf2, 0x68, 0xdc, 0xb9, 0xa2, 0x81, 0x93, 0xb8, 0xcc, 0x49, 0xa6, 0x01,
	0x65, 0x5c, 0x2c, 0x45, 0xf2, 0x7b, 0x3e, 0x4d, 0x03, 0x64, 0x57, 0x5c, 0x2a, 0x8d, 0x7d, 0xa8,
	0x8f, 0x67, 0x6e, 0x14, 0xf2, 0x00, 0x19, 0x21, 0xb0, 0x96, 0x38, 0x31, 0x6a, 0x6a, 0x5b, 0x35,
	0xeb, 0x76, 0x7e, 0x36, 0x7e, 0xac, 0xc0, 0x5a, 0x9f, 0xd2, 0xeb, 0xac, 0x19, 0x72, 0x37, 0xc9,
	0x9b, 0xab, 0x76, 0x7e, 0x26, 0x7b, 0xb0, 0x2e, 0x42, 0x11, 0xa1, 0xb6, 0x92, 0x2b, 0x24, 0x20,
	0x0f, 0x60, 0xc3, 0x99, 0x89, 0x80, 0x32, 0x6d, 0x35, 0x2f, 0x17, 0x88, 0x58, 0x50, 0xcf, 0x5d,
	0x8a, 0x79, 0x8a, 0xda, 0x5a, 0x5b, 0x35, 0x9b, 0xdd, 0x1d, 0xab, 0xf0, 0x68, 0x65, 0xdf, 0xb8,
	0x98, 0xa7, 0x68, 0x6f, 0xba, 0xc5, 0x89, 0x3c, 0x86, 0x26, 0xc7, 0xe8, 0x72, 0x92, 0x16, 0x03,
	0x4e, 0xb5, 0xf5, 0xb6, 0x6a, 0x6e, 0x0e, 0x15, 0xbb, 0x91, 0xd5, 0xcb, 0xb9, 0xa7, 0xa4, 0x0b,
	0xf5, 0x92, 0xc3, 0xb4, 0x8d, 0xb6, 0x6a, 0x6e, 0x75, 0xc9, 0xe2, 0xe2, 0x85, 0xbd, 0xa1, 0x62,
	0x2f, 0x69, 0xe4, 0x14, 0x5a, 0x39, 0xf0, 0x1c, 0x11, 0xd2, 0x64, 0x32, 0x75, 0x04, 0x6a, 0xb5,
	0x5c, 0xaa, 0x5b, 0x32, 0x6e, 0xab, 0x4c, 0xce, 0xba, 0x28, 0xe3, 0xb6, 0xef, 0xdd, 0xd2, 0x9c,
	0x38, 0x02, 0xfb, 0xbb, 0xb0, 0x53, 0xdc, 0x19, 0x26, 0xfe, 0x24, 0x46, 0x11, 0xd0, 0xa9, 0xf1,
	0x08, 0x9a, 0x6f, 0x50, 0x64, 0x8e, 0x6c, 0xfc, 0x32, 0x43, 0x2e, 0xfe, 0x16, 0x9e, 0x71, 0x0c,
	0x3b, 0xef, 0x67, 0xc8, 0xe6, 0x19, 0x8f, 0x97, 0xc4, 0x03, 0x68, 0xc8, 0xb4, 0x26, 0x29, 0xc3,
	0xcb, 0xf0, 0xa6, 0xd8, 0xc5, 0xb6, 0x2c, 0x8e, 0xf3, 0x9a, 0xf1, 0x0c, 0x60, 0x40, 0xa3, 0x08,
	0xbd, 0x6c, 0x0c, 0x72, 0x00, 0xeb, 0x59, 0x64, 0x5c, 0x53, 0xdb, 0xab, 0xe6, 0x56, 0xb7, 0x51,
	0x89, 0xd4, 0x96, 0x3d, 0xe3, 0x1d, 0x6c, 0x65, 0xf0, 0x1c, 0x39, 0x77, 0x7c, 0x24, 0x7b, 0xb7,
	0x37, 0x3d, 0x54, 0xe4, 0xae, 0x89, 0x0e, 0xb5, 0x58, 0x12, 0xe4, 0x42, 0x87, 0x8a, 0x5d, 0x16,
	0xfa, 0x75, 0xa8, 0x79, 0x34, 0x11, 0x98, 0x08, 0xc3, 0x84, 0x6d, 0xe9, 0x8d, 0xa7, 0x34, 0xe1,
	0x48, 0xb4, 0x3f, 0x64, 0x0b, 0xd1, 0x93, 0xe7, 0xb0, 0x59, 0xee, 0x95, 0x34, 0xa0, 0x3e, 0xec,
	0xd9, 0x27, 0x83, 0xd1, 0xa7, 0x53, 0xbb, 0xa5, 0x64, 0x70, 0xdc, 0x1b, 0x9f, 0xda, 0xfd, 0xde,
	0xe0, 0xac, 0xa5, 0x66, 0xb0, 0xf7, 0xf1, 0xe4, 0xed, 0xa8, 0x3f, 0x1a, 0x9d, 0xb5, 0x56, 0xba,
	0x3f, 0x55, 0x39, 0xef, 0x07, 0xf9, 0x20, 0xc8, 0x11, 0xd4, 0x8a, 0x44, 0xc9, 0xc3, 0x85, 0xbf,
	0x6a, 0xc6, 0x7a, 0xd5, 0xb8, 0xa1, 0x90, 0x17, 0x00, 0xcb, 0x80, 0x89, 0xbe, 0x68, 0xdf, 0x49,
	0xfd, 0x8e, 0xf4, 0x50, 0x25, 0xc7, 0xd0, 0x3c, 0x77, 0xae, 0xf1, 0x56, 0xce, 0x55, 0x92, 0xbe,
	0xbb, 0x80, 0x4b, 0x8e, 0xa1, 0x98, 0x2a, 0x79, 0x29, 0x4d, 0x0f, 0x02, 0x47, 0x90, 0xbd, 0x8a,
	0xa6, 0x48, 0x5f, 0xbf, 0x5f, 0x5d, 0x51, 0x91, 0x63, 0x26, 0x3e, 0x54, 0xfb, 0xdf, 0xd5, 0x5f,
	0xaf, 0x5f, 0xfd, 0xe3, 0x3d, 0xfb, 0x2c, 0xf5, 0xbe, 0xa1, 0xfb, 0x14, 0x6f, 0x9c, 0x38, 0x8d,
	0xb0, 0xe3, 0x45, 0x21, 0x26, 0xc5, 0x33, 0x2f, 0xff, 0x26, 0x9f, 0xff, 0xe7, 0x82, 0xec, 0xa7,
	0x83, 0xac, 0x7a, 0x81, 0xbb, 0x91, 0xc3, 0xa3, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xa6, 0x8e,
	0x45, 0x37, 0xa6, 0x04, 0x00, 0x00,
}
